Turtle-superstar - The Perfect Grouping And Fragment Qualification Syntax


nomenclatura
    attribute            add property/value pairs globally to the type, 
                            ie standard rdf procedure
    qualify                add property/value pairs in a local context to the occurrence
                            (note that the occurrence entails the unqualified type)
    contextualize        same as qualify, but rhymes with ©
    annotate             same as qualify, but use with care b/c it is so common


©   contextualization is indicated by an otherwise little used special character
    we don't use @ 'annotates' because it has too many meanings already
    
    contextualization can be applied to
    - a term (a node or an edge)
    - a triple (the whole statement as an entity in its own right, not forEach term)
    - a graph (the whole graph as an entity in its own right, not forEach triple)
      (stand-alone (nested or not) or as term (again node or edge))
      (a triple can be understood as a singleton graph)
    
    contextualizing a term or graph means annotating the specific instance
        without saying something about its type in general


©   usually the contextualization sign is accompanied by a name,
    e.g.
        ©1
    when it is defined it is closed by a '>' sign
    e.g.
        ©1>
   also when directly annotated
    e.g.
        ©1>[ :a :b ]
    in the case of direct annotation the name may be left undefined 
    (a bnode will be generated by the system)
    e.g.
        ©>[ :a :b ]


    the contextualization identifier is added after a
        - term (subject, predicate object)
        - triple
        - graph

Terms
    terms are either nodes or the edge of a statement
    e.g.
        :s ©1> :p :o .          # addressing the subject node
        :s :p :©2> o .          # addressing the predicate node
    the actual annotation may then be added in further statements
    here the ©… identifier is followed not by '>' (or '[..]') but by a white space
    e.g.
        ©1 :a :b .              # no trailing '>'  
    alternatively, contextualizations may be added in place
    e.g.
        :s :p ©>[ :a :b ] :o .
        :s :p :o . ©>[ :y :z ]
    both approaches may be combined
    e.g.
        :s :p ©1>[ :a :b ] :o .
        ©1 :c :d .

    a singleton '-' may be added after the '©' and before the '>' to improve readability
    eg
        :s :p ©->[ :a :b ] :o .
        :s :p :o . ©-1->[ :y :z ]
        :s ©-2-> :p :o .
        :s :p :o1 . ©-3->
         ©-3 :u :w .

Triples
    triples can be terminated by ',', ';' and '.'
    e.g.
        :s :p :o1 ; ©1>         # addressing the triple as an entity of its own right
           :q :o2 , ©2>         # same here
              :o3 . ©3>         # and here

Graphs
    {...} groups of triples may be addressed together
    graphs are always implicitly named.
    
     
    TODO    graphs are, but triples aren't ???
            is there an issue with types and tokens lurking behind this ???
            
            
    they may be explicitly named with a '©-name->' annotation
    they can occur 
        on their own ("stand-alone")
        as terms inside statements 
    e.g. a stand-alone graph
        { :s :p :o .
          :a :b :c } .                   # see note "Dots ('.') in and after graphs" below
    e.g. graphs inside statements
        :a :b { :s :p :o } .
        { :s :p :o } :b :c .
    e.g. a statemet composed of graphs (aka generalized rdf)
        { :s :p :o } { :u :v :w } { :x :y :z } .
        
    a graph may be explicitly named
        { :s :p :o .
          :a :b :c } . ©_:1>
    it may be annotated in place
        { :s :p :o .
          :a :b :c } . ©_:1>[:y :z ]
    or separately
        { :s :p :o .
          :a :b :c } . ©_:1> 
        ©_:1 :y :z .

    annotations on graphs refer to the graph as a whole, 
        not individually to each triple it contains
        (such forEach semantics may be added later, via syntactic sugar + properties)
    e.g.
        { :s :p :o .
          :a :b :c } :y :z .
    is NOT equivalent to
        :s :p :o . ©[ :y :z ]
        :a :b :c . ©[ :y :z ]
    and vice versa

    graphs can be nested
    e.g.
        { { :s :p :o .
            :u :v :w } .                           # stand-alone graph
          { :a :b :c .                             # graoh as subject
            :d :e :f } :g { :h :i :j , :k :l } .   # graph as object
          :m :n :o                                 # a good old triple
        } :p :o .                                  # annotating the outer graph

    triples can be understood as implicitly being singleton graphs
    e.g.
        { :s :p :o .
          :a :b :c } :y :z .
    is equivalent to
        { :s :p :o } . ©1>
        { :a :b :c } . ©2>
      :G1 rdfss:hasPart ©1 , ©2 ;
          :y :z .
    (note how the graph annotation does NOT apply to each triple individually)
    nesting of graphs can be understood as a partOf relation
    this could even be generalized to terms being partOf triples - but is that useful?

    annotating nested graphs
    
    
    
    
    TODO    annotations (better: contexts) refer only to the occurrence
            not to the graph as a type
            ie. there is a difference between contextualizing a graph in a statement
                    { :s :p :o } ©1>[ :x :y ] :a :b .
                and attributing it
                    { :s :p :o } :x :y ; :a :b .
                the former refers to the graph only in the context of that statement
                the latter refers to the graph as a type, globally
            applied to stand-alone graphs that means that 
                contexting creates a reference to an occurrence, 
                    { :s :p :o . :a :b :c } . ©>[ :v :w ]
                attributing refers to the type
                    { :s :p :o . :a :b :c } :x :y .

            how do we map that to rdf-star???
            and how much does it extend basic rdf semantics?



    Dots ('.') in and after graphs
    statements are concluded with a dot (that much is not surprising)
    the last statement inside a graph '{ ... }' doesn't need to provide a dot 
        if it's not annotated
        otherwise it does, to differentiate annotation on the object vs on the statement
    a graph needs to be followed by a dot if it's not part of a statement
        (that ensures differentiation from the subject of the next statement)
    e.g.
        { :s :p :o .
          :a :b :c } ©_:1> :y :z .      # the dot is at the end of the line
    and it may also be written as
        { :s :p :o .
          :a :b :c } . ©_:1>[:y :z ]    # the dot is now before the ©>
    or
        { :s :p :o .
          :a :b :c } . ©_:1>            # again the dot is before the ©>
        ©_:1 :y :z .
    



Mapping to RDF 1.0/1.1

    { :s :p ©1> :o .
      :a :b :c } ©2> .
    ©1 :u :w .
    ©2 :y :z .

    < - - - >

    _:©1 rdfss:qualifies :p ;
        :u :w .
    _:©2 rdfss:annotates <<( :a :b :c )>> ;
        :g :h .

TODO
    how to map © names to proper IRIs or blank nodes
    mapping nesting


Mini Tutorial ©ontextualization syntax
       ©1>               context declared
                                 named
       ©1>[:a :b ]       context declared
                                 named
                                 described    
       ©>[:c :d ]        context declared
                                 anonymous
                                 described

   e.g.
        :s ©1> :p :o .
        :s :p ©2[ :src :X ] :o .
        :s :p :o ©[ :age 18 ] .
        ©1 :c :d .
        ©2 :date :today




Querying

querying has two main aspects
- asserted statements
- unasserted statements

unasserted statements need special treatment because they can’t be allowed to show up in queries that don’t explicitly ask for them

asserted statements need to be treated equal no matter if they are annotated or not (except of course when annotations become a part of the query pattern)

   # all asserted statements, with annotations if given
   # ¿including system annotations like graph containement?
   ?s ?p ?o ?©
   OPTIONAL ?© ?a ?b

