[
  {
    "kind": 1,
    "language": "markdown",
    "value": "# TBD\n\n    the final query  \n    that combines the results of all experiments so far\n    first nesting\n    then fragments\n    then everything combined\n\n    now with new dataset 'feb25data.trig'\n\n    prerequisite: \n    the default graph must be configured as union of all named graphs\n\n    tested on oxigraph being available at \n    http://localhost:7878/query\n    run as a docker image with\n\n    docker run -d --name oxigraph --rm -v $PWD/data:/data -p 7878:7878 oxigraph/oxigraph serve --location /data --bind 0.0.0.0:7878 --union-default-graph",
    "metadata": {}
  },
  {
    "kind": 1,
    "language": "markdown",
    "value": "## nesting",
    "metadata": {}
  },
  {
    "kind": 2,
    "language": "sparql",
    "value": "# [endpoint=./feb25data.trig]\n# [use_default_graph_as_union=true]\n\n# so far so good for graph :A\n# but not for all graphs\n\nPREFIX   :   <http://rat.io/>\nPREFIX ng:   <http://rdf.ng/>\n\nSELECT DISTINCT\n    ?graph      # the graph annotated\n    ?prop       # the annotation property\n    ?val        # the annotation value\n    ?target     # the graph which is annotated directly\n    ?source     # the graph in which the annotation takes place\n    ?means      # the type of reference to the annotated graph\n\nWHERE {\n\n    # subquery to collect the graphs nesting ?graph\n    #       see https://stackoverflow.com/questions/5198889/\n    { SELECT ?graph ?nesting WHERE {\n\n        # Virtuoso needs this. does it hurt anywhere else?\n        {\n            SELECT distinct ?nesting\n            WHERE {\n            ?x ng:in ?nesting\n            }\n        }\n\n        VALUES ?graph { :A }                # BIND ?graph to graph(s) of interest\n                                            # moved here b/o Allegrograph\n        ?graph ng:in* ?path .\n        ?path  ng:in+ ?nesting .  \n    } }\n\n\n    # a graph can be annotated directly or via inheritance \n    # Direct                    directly, the graph as subject\n    #       Self        DS      in the graph itself\n    #       Nesting     DN      in a nesting graph\n    #       External    DX      in any other graph\n    # Inherit                   inherited, a nesting graph as subject\n    #       Self        IS      in the nesting graph itself\n    #       Nesting     IN      in an outer nesting graph\n    #       External    IX      in any other graph\n\n\n    # DS    directly, the graph as subject, in the graph itself\n    #       :A      :A :pA ng:DS .\n    #       :D      :D :pD ng:IS .\n    #       :K      :K :pK ng:DS .\n    {   GRAPH ?graph { ?graph ?prop ?val }\n        BIND ( ?graph AS ?target )\n        BIND ( ?graph AS ?source )\n        BIND ( ng:DirectSelf AS ?means )\n    } \n    \n    UNION\n\n    # DN    directly, the graph as subject, in a nesting graph\n    #       :A      :A :pB ng:DN .\n    #               :A :pD ng:DN .\n    #       :B      :B :pC ng:IN .\n    {\n    \tGRAPH ?nesting { ?graph ?prop ?val }\n        FILTER ( ?prop != ng:in )\n        FILTER EXISTS { ?graph ng:in* ?nesting }    # virtuoso needs this\n        BIND ( ?graph AS ?target )\n        BIND ( ?nesting AS ?source )\n        BIND ( ng:DirectNesting AS ?means )\n    } \n    \n    UNION\n\n    # DX    directly, the graph as subject, in any other graph\n    #       :A      :A :pK ng:DX .\n    #               :A :pH ng:DX .\n    #       :B      :B :pK ng:IX .\n    #               :B :pH ng:IX .\n    {   \n        GRAPH ?extraGraph { ?graph ?prop ?val . }\n        FILTER NOT EXISTS { ?graph ng:in* ?extraGraph . }\n        FILTER ( ?prop != ng:in )                   # jena needs this\n        BIND ( ?graph AS ?target )\n        BIND ( ?extraGraph AS ?source )\n        BIND ( ng:DirectExternal AS ?means )\n    } \n    \n    UNION\n \n    # IS    inherited, a nesting graph as subject, in that graph itself\n    #       :A      :D :pD ng:IS .       \n    {   \n        GRAPH ?nesting { ?nesting ?prop ?val  }\n        BIND ( ?nesting AS ?target )\n        BIND ( ?nesting AS ?source )\n        BIND ( ng:InheritSelf AS ?means )\n    } \n    \n    UNION\n    \n    # IN    inherited, a nesting graph as subject, in an outer nesting graph\n    #       :A      :B :pC ng:IN .\n    {   \n    \tGRAPH ?outerNesting { ?nesting ?prop ?val }\n        FILTER ( ?nesting != ?outerNesting)\n        FILTER EXISTS {\n      \t\t?nesting ng:in+ ?outerNesting . \n    \t}\n        FILTER ( ?prop != ng:in )\n        BIND ( ?nesting AS ?target )\n        BIND ( ?outerNesting AS ?source )\n        BIND ( ng:InheritNesting AS ?means )\n    } \n    \n    UNION\n\n    # IX    inherited, a nesting graph as subject, in any other graph\n    #       :A      :B :pH ng:IX .\n    #               :B :pK ng:IX .\n    {   \n    \tGRAPH ?extraGraph { ?nesting ?prop ?val }\n    \tFILTER NOT EXISTS { ?nesting ng:in* ?extraGraph }\n        FILTER ( ?prop != ng:in )                   # jena needs this\n        BIND ( ?nesting AS ?target )\n        BIND ( ?extraGraph AS ?source )\n        BIND ( ng:InheritExternal AS ?means )\n    }\n\n} ORDER BY ?graph ?means ?target ?source ?prop ?val \n\n\n# graph\t    prop    val\t        target  source  means\n# :A        :pH     ng:DX       :A      :H      ng:DirectExternal\n# :A        :pK     ng:DX       :A      :K      ng:DirectExternal\n# :A        :pB     ng:DN       :A      :B      ng:DirectNesting   \n# :A        :pD     ng:DN       :A      :D      ng:DirectNesting\n# :A        :pA     ng:DS       :A      :A      ng:DirectSelf\n# :A        :pH     ng:IX       :B      :H      ng:InheritExternal\n# :A        :pK     ng:IX       :B      :K      ng:InheritExternal\n#  A        :pC     ng:IN       :B      :C      ng:InheritNesting\n# :A        :pD     ng:IS       :D      :D      ng:InheritSelf",
    "metadata": {}
  },
  {
    "kind": 1,
    "language": "markdown",
    "value": "testing\n            ok      not ok  hiccups     \noxigraph    x\nstardog     x\ngraphdb     x\nrdf4j       x\nrdfox       x\nvirtuoso    x               brittle on 7.3 b/o bug\nallegro     x               one issue resolved\njena        x               some serious rewriting of filters\ndydra               #       very incomplete\nqlever              x       EXISTS/NOT not yet implemented\n\ntodo\n    oracle\n    aws\n    blazegraph\n\n\nallegrogaph IS returns 2 results too many, from :B and :C\n            ->  move \"BIND ( :A AS ?graph )\" into the sub-query\n\n\nvirtuoso    see https://github.com/openlink/virtuoso-opensource/issues/180#issuecomment-445549691\n            that DID work, but it introduces another sub-query inside the sub-query :-/\n            -> TODO check compatability of sub-sub-query\n\nvirtuoso    DN  returns one too many, :H\n            ->  add \"FILTER EXISTS { ?graph ng:in* ?nesting }\"\n                this shouldn't be necessary,\n                aber wenn's dem weltfrieden dient...\n\njena        requires to let the subquery run over the union graph \n                <urn:x-arq:UnionGraph>\n            not the FROM <urn:x-arq:UnionGraph>, \n                \"because UnionGraph is not a real graph\"\n                see https://stackoverflow.com/questions/79453034/querying-over-named-graphs-and-union-graph-in-jena\n            -> TODO check how many stores would support that approach\n\n            this outlier-ish configuration also requires \n                rewriting of al filters over nesting path\n                as otherwise\n                DX  returns two results too many, :B and :D\n                IN  returns nothing\n                IX  returns one too many, :C\n\n\nqlever      Error processing query\n            Invalid SPARQL query: Built-in function \"notexists{?graphng:in*?extragraph.}\" not yet implemented; if you need it, just add it to SparqlQleverVisitor.cpp::visitTypesafe(Parser::BuiltInCallContext following the already implemented functions there\n            same for EXISTS\n            but also\n            A variable that is used as the graph specifier of a `GRAPH ?var {...}` clause may not appear in the body of that clause\n            that is the death sentence foor qlever\n\n\ndydra       all union queries work as stand alone\n            however, in the combined query only direct nesting works, but nothing else\n            \n",
    "metadata": {}
  },
  {
    "kind": 1,
    "language": "markdown",
    "value": "### debugging virtuoso\n\ntwo issues: an additional sub-select, and a problem with filters\nboth are problems of virtuoso\nthe first one can be worked around\n    but it doesn't look nice\nthe second one is a bug and fixed in the commercial version\n    not good, but also not my problem",
    "metadata": {}
  },
  {
    "kind": 2,
    "language": "sparql",
    "value": "PREFIX   :   <http://rat.io/>\nPREFIX ng:   <http://rdf.ng/>\n\nSELECT DISTINCT ?graph ?prop ?val ?target ?source ?means\n\nWHERE {\n\n    BIND ( :A AS ?graph ) .\n\n    { SELECT ?graph ?nesting WHERE {\n\n        # the query first threw an error\n        #       Virtuoso 37000 Error TR...: Query contains a transitive ...\n        # that could be fixed with adding another sub-select into the path-finding sub-select\n        # see https://github.com/openlink/virtuoso-opensource/issues/180#issuecomment-445549691\n        {\n            SELECT distinct ?nesting\n            WHERE {\n            ?x ng:in ?nesting\n            }\n        }\n\n        VALUES ?graph { :A }    # anchor ?graph to :A\n        ?graph ng:in* ?path .\n        ?path  ng:in+ ?nesting .\n    } }\n\n\n    # DS    directly, the graph as subject, in the graph itself\n    #       :A      :A :pA ng:DS .\n    #       :D      :D :pD ng:IS .\n    #       :K      :K :pK ng:DS .\n    {   GRAPH ?graph { ?graph ?prop ?val }\n        BIND ( ?graph AS ?target )\n        BIND ( ?graph AS ?source )\n        BIND ( ng:DirectSelf AS ?means )\n    } \n    \n\n} ORDER BY ?graph ?means ?target ?source ?prop ?val \n\n\n# graph  prop    val\t        target  source  means\n# :A        :pA     ng:DS       :A      :A      ng:DirectSelf",
    "metadata": {}
  },
  {
    "kind": 2,
    "language": "sparql",
    "value": "# virtuoso 7.2 seems to have a bug that they don't bother to fix in the OS version\n# the following query first threw an error\n#     Virtuoso 37000 Error SP031: Redundant FILTER after BIND in UNION causes internal error\n# then i commented out all filters, and it worked\n# then i re-introduced all filters one by one (the simple ones first, then the EXISTS, then the NOT EXISTS)\n# and it worked\n# see https://github.com/openlink/virtuoso-opensource/issues/822\n#     where it says that this bug is fixed in the commercial-only version 8\n\nPREFIX   :   <http://rat.io/>\nPREFIX ng:   <http://rdf.ng/>\n\nSELECT DISTINCT ?graph ?prop ?val ?target ?source ?means\n\nWHERE {\n\n    BIND ( :A AS ?graph ) .\n\n    { SELECT ?graph ?nesting WHERE {\n\n        # the query first threw an error\n        #       Virtuoso 37000 Error TR...: Query contains a transitive ...\n        # that could be fixed with adding another sub-select into the path-finding sub-select\n        # see https://github.com/openlink/virtuoso-opensource/issues/180#issuecomment-445549691\n        # see https://github.com/openlink/virtuoso-opensource/issues/180#issuecomment-445549691\n        {\n            SELECT distinct ?nesting\n            WHERE {\n            ?x ng:in ?nesting\n            }\n        }\n\n        VALUES ?graph { :A }    # anchor ?graph to :A\n        ?graph ng:in* ?path .\n        ?path  ng:in+ ?nesting .\n    } }\n\n\n    # DS    directly, the graph as subject, in the graph itself\n    #       :A      :A :pA ng:DS .\n    #       :D      :D :pD ng:IS .\n    #       :K      :K :pK ng:DS .\n    {   GRAPH ?graph { ?graph ?prop ?val }\n        BIND ( ?graph AS ?target )\n        BIND ( ?graph AS ?source )\n        BIND ( ng:DirectSelf AS ?means )\n    } \n    \n    UNION\n\n    # DN    directly, the graph as subject, in a nesting graph\n    #       :A      :A :pB ng:DN .\n    #               :A :pD ng:DN .\n    #       :B      :B :pC ng:IN .\n    {\n    \tGRAPH ?nesting { ?graph ?prop ?val }\n        FILTER ( ?prop != ng:in )\n        BIND ( ?graph AS ?target )\n        BIND ( ?nesting AS ?source )\n        BIND ( ng:DirectNesting AS ?means )\n    } \n\n    UNION\n\n    # DX    directly, the graph as subject, in any other graph\n    #       :A      :A :pK ng:DX .\n    #               :A :pH ng:DX .\n    #       :B      :B :pK ng:IX .\n    #               :B :pH ng:IX .\n    {   \n        GRAPH ?extraGraph { ?graph ?prop ?val . }\n        FILTER NOT EXISTS { ?graph ng:in* ?extraGraph . }\n        BIND ( ?graph AS ?target )\n        BIND ( ?extraGraph AS ?source )\n        BIND ( ng:DirectExternal AS ?means )\n    } \n\n    UNION\n    \n    # IN    inherited, a nesting graph as subject, in an outer nesting graph\n    #       :A      :B :pC ng:IN .\n    {   \n        # GRAPH ?outerNesting { ?innerNesting ?prop ?val }\n        # FILTER EXISTS {\n      \t# \t?graph ng:in+ ?innerNesting .\n      \t# \t?innerNesting ng:in+ ?outerNesting . \n      \t# \t?outerNesting ng:in+ ?nesting . \n    \t# }\n        # FILTER ( ?prop != ng:in )\n        # BIND ( ?innerNesting AS ?target )\n        # BIND ( ?outerNesting AS ?source )\n        # BIND ( ng:InheritNesting AS ?means )\n    \tGRAPH ?outerNesting { ?nesting ?prop ?val }\n        FILTER ( ?nesting != ?outerNesting)\n        FILTER EXISTS {\n      \t\t?nesting ng:in+ ?outerNesting . \n    \t}\n        FILTER ( ?prop != ng:in )\n        BIND ( ?nesting AS ?target )\n        BIND ( ?outerNesting AS ?source )\n        BIND ( ng:InheritNesting AS ?means )\n    } \n    \n    UNION\n \n    # IS    inherited, a nesting graph as subject, in that graph itself\n    #       :A      :D :pD ng:IS .       \n    {   \n        GRAPH ?nesting { ?nesting ?prop ?val  }\n        BIND ( ?nesting AS ?target )\n        BIND ( ?nesting AS ?source )\n        BIND ( ng:InheritSelf AS ?means )\n    } \n\n    UNION\n\n    # IX    inherited, a nesting graph as subject, in any other graph\n    #       :A      :B :pH ng:IX .\n    #               :B :pK ng:IX .\n    {   \n    \tGRAPH ?extraGraph { ?nesting ?prop ?val }\n    \tFILTER NOT EXISTS { ?nesting ng:in* ?extraGraph }\n        BIND ( ?nesting AS ?target )\n        BIND ( ?extraGraph AS ?source )\n        BIND ( ng:InheritExternal AS ?means )\n    }\n\n} ORDER BY ?graph ?means ?target ?source ?prop ?val \n\n# graph\t    prop    val\t        target  source  means\n# :A        :pH     ng:DX       :A      :H      ng:DirectExternal\n# :A        :pK     ng:DX       :A      :K      ng:DirectExternal\n# :A        :pB     ng:DN       :A      :B      ng:DirectNesting   \n# :A        :pD     ng:DN       :A      :D      ng:DirectNesting\n# :A        :pA     ng:DS       :A      :A      ng:DirectSelf\n# :A        :pH     ng:IX       :B      :H      ng:InheritExternal\n# :A        :pK     ng:IX       :B      :K      ng:InheritExternal\n#  A        :pC     ng:IN       :B      :C      ng:InheritNesting\n# :A        :pD     ng:IS       :D      :D      ng:InheritSelf",
    "metadata": {}
  },
  {
    "kind": 1,
    "language": "markdown",
    "value": "### debugging jena",
    "metadata": {}
  },
  {
    "kind": 2,
    "language": "sparql",
    "value": "# the following query gives the expected results in Jena\n\n\n\nPREFIX   :   <http://rat.io/>\nPREFIX ng:   <http://rdf.ng/>\n\nSELECT DISTINCT ?graph ?prop ?val ?target ?source ?means \n\nWHERE {\n  \n    # BIND ( :A AS ?graph ) . \n    { SELECT ?graph ?nesting WHERE {\n        GRAPH <urn:x-arq:UnionGraph> {\n        BIND ( :A AS ?graph ) .\n        ?graph ng:in* ?path .\n        ?path  ng:in+ ?nesting . \n      }\n    } }\n    \n\n    # DS    directly, the graph as subject, in the graph itself\n    {   GRAPH ?graph { ?graph ?prop ?val }\n        BIND ( ?graph AS ?target )\n        BIND ( ?graph AS ?source )\n        BIND ( ng:DirectSelf AS ?means )\n    } \n\n    UNION\n\n    # DN    directly, the graph as subject, in a nesting graph\n    {\n    \tGRAPH ?nesting { ?graph ?prop ?val }\n        FILTER ( ?prop != ng:in )\n        BIND ( ?graph AS ?target )\n        BIND ( ?nesting AS ?source )\n        BIND ( ng:DirectNesting AS ?means )\n    } \n    \n    UNION\n\n    # DX    directly, the graph as subject, in any other graph\n  \n  \t# two too many:  :B and :D\n  \n  {   \n        GRAPH ?extraGraph { ?graph ?prop ?val . }\n        # FILTER NOT EXISTS { ?graph ng:in* ?extraGraph . }\n    \tFILTER NOT EXISTS {                                     # added for jena\n      \t\tGRAPH <urn:x-arq:UnionGraph> { ?graph ng:in* ?extraGraph . }\n   \t\t}\n        FILTER ( ?prop != ng:in )\t\t\t\t\t\t\t\t# added for jena\n        BIND ( ?graph AS ?target )\n        BIND ( ?extraGraph AS ?source )\n        BIND ( ng:DirectExternal AS ?means )\n    } \n    \n    UNION\n \n    # IS    inherited, a nesting graph as subject, in that graph itself\n    {   \n        GRAPH ?nesting { ?nesting ?prop ?val  }\n        BIND ( ?nesting AS ?target )\n        BIND ( ?nesting AS ?source )\n        BIND ( ng:InheritSelf AS ?means )\n    } \n  \n    UNION\n    \n    # IN    inherited, a nesting graph as subject, in an outer nesting graph\n  \n    # returns nothing \n  \n    {   \n    \tGRAPH ?outerNesting { ?nesting ?prop ?val }\n        FILTER ( ?nesting != ?outerNesting)\n        FILTER EXISTS {                                     # added for jena\n      \t\tGRAPH <urn:x-arq:UnionGraph> { ?nesting ng:in+ ?outerNesting . }\n   \t\t}\n        FILTER ( ?prop != ng:in )\n        BIND ( ?nesting AS ?target )\n        BIND ( ?outerNesting AS ?source )\n        BIND ( ng:InheritNesting AS ?means )\n    } \n  \n    UNION\n\n    # IX    inherited, a nesting graph as subject, in any other graph\n  \n    # one too many: :C\n    {   \n    \tGRAPH ?extraGraph { ?nesting ?prop ?val }\n    \tFILTER NOT EXISTS { ?nesting ng:in* ?extraGraph }\n    \tFILTER NOT EXISTS {                                     # added for jena\n      \t\tGRAPH <urn:x-arq:UnionGraph> { ?nesting ng:in* ?extraGraph . }\n   \t\t}\n        FILTER ( ?prop != ng:in )\t\t\t\t\t\t\t\t# added for jena\n        BIND ( ?nesting AS ?target )\n        BIND ( ?extraGraph AS ?source )\n        BIND ( ng:InheritExternal AS ?means )\n    }\n  \n} ORDER BY ?graph ?means ?target ?source ?prop ?val \n\n\n\n# graph\t    prop    val\t        target  source  means\n# :A        :pH     ng:DX       :A      :H      ng:DirectExternal\n# :A        :pK     ng:DX       :A      :K      ng:DirectExternal\n# :A        :pB     ng:DN       :A      :B      ng:DirectNesting   \n# :A        :pD     ng:DN       :A      :D      ng:DirectNesting\n# :A        :pA     ng:DS       :A      :A      ng:DirectSelf\n# :A        :pH     ng:IX       :B      :H      ng:InheritExternal\n# :A        :pK     ng:IX       :B      :K      ng:InheritExternal\n#  A        :pC     ng:IN       :B      :C      ng:InheritNesting\n# :A        :pD     ng:IS       :D      :D      ng:InheritSelf",
    "metadata": {}
  },
  {
    "kind": 1,
    "language": "markdown",
    "value": "### debugging dydra",
    "metadata": {}
  },
  {
    "kind": 2,
    "language": "sparql",
    "value": "# [endpoint=./feb25data.trig]\n# [use_default_graph_as_union=true]\n\n# so far so good for graph :A\n# but not for all graphs\n\nPREFIX   :   <http://rat.io/>\nPREFIX ng:   <http://rdf.ng/>\n\nSELECT DISTINCT\n    ?graph      # the graph annotated\n    ?prop       # property\n    ?val        # value\n    ?target     # the graph annotated directly\n    ?source     # the graph in which the annotation takes place\n    ?means      # the kind of access to the annotated graph\n\n# FROM <urn:dydra:all>\n# FROM NAMED <urn:dydra:named>\n\nWHERE {\n\n    # BIND ?graph for testing\n    # GRAPH ?graph { ?x ?y ?z } .   # bricolage #\n    # VALUES ?graph { :A } .          # good for multiple graphs\n    # BIND ( :A AS ?graph ) .       # most elegant\n\n    # subquery to collect the graphs nesting ?graph\n    #       see https://stackoverflow.com/questions/5198889/\n    { SELECT ?graph ?nesting WHERE {\n          GRAPH <urn:dydra:all> {\n          VALUES ?graph { :A } .\n          ?graph ng:in* ?path .\n          ?path  ng:in+ ?nesting .\n      }\n    } }\n\n\n    # a graph can be annotated directly or via inheritance \n    # Direct                    directly, the graph as subject\n    #       Self        DS      in the graph itself\n    #       Nesting     DN      in a nesting graph\n    #       External    DX      in any other graph\n    # Inherit                   inherited, a nesting graph as subject\n    #       Self        IS      in the nesting graph itself\n    #       Nesting     IN      in an outer nesting graph\n    #       External    IX      in any other graph\n\n\n    # DS    directly, the graph as subject, in the graph itself\n    #       :A      :A :pA ng:DS .\n    #       :D      :D :pD ng:IS .\n    #       :K      :K :pK ng:DS .\n    {   GRAPH ?graph { ?graph ?prop ?val }\n        BIND ( ?graph AS ?target )\n        BIND ( ?graph AS ?source )\n        BIND ( ng:DirectSelf AS ?means )\n    } \n    \n    UNION\n\n    # DN    directly, the graph as subject, in a nesting graph\n    #       :A      :A :pB ng:DN .\n    #               :A :pD ng:DN .\n    #       :B      :B :pC ng:IN .\n    {\n      GRAPH ?nesting { ?graph ?prop ?val }\n        FILTER ( ?prop != ng:in )\n        BIND ( ?graph AS ?target )\n        BIND ( ?nesting AS ?source )\n        BIND ( ng:DirectNesting AS ?means )\n    } \n    \n    UNION\n\n    # DX    directly, the graph as subject, in any other graph\n    #       :A      :A :pK ng:DX .\n    #               :A :pH ng:DX .\n    #       :B      :B :pK ng:IX .\n    #               :B :pH ng:IX .\n    {   \n        GRAPH ?extraGraph { ?graph ?prop ?val . }\n        FILTER NOT EXISTS { ?graph ng:in* ?extraGraph . }\n        BIND ( ?graph AS ?target )\n        BIND ( ?extraGraph AS ?source )\n        BIND ( ng:DirectExternal AS ?means )\n    } \n    \n    UNION\n \n    # IS    inherited, a nesting graph as subject, in that graph itself\n    #       :A      :D :pD ng:IS .       \n    {   \n        GRAPH ?nesting { ?nesting ?prop ?val  }\n        BIND ( ?nesting AS ?target )\n        BIND ( ?nesting AS ?source )\n        BIND ( ng:InheritSelf AS ?means )\n    } \n    \n    UNION\n    \n    # IN    inherited, a nesting graph as subject, in an outer nesting graph\n    #       :A      :B :pC ng:IN .\n    {   \n        # GRAPH ?outerNesting { ?innerNesting ?prop ?val }\n        # FILTER EXISTS {\n      \t# \t?graph ng:in+ ?innerNesting .\n      \t# \t?innerNesting ng:in+ ?outerNesting . \n      \t# \t?outerNesting ng:in+ ?nesting . \n    \t# }\n        # FILTER ( ?prop != ng:in )\n        # BIND ( ?innerNesting AS ?target )\n        # BIND ( ?outerNesting AS ?source )\n        # BIND ( ng:InheritNesting AS ?means )\n    \tGRAPH ?outerNesting { ?nesting ?prop ?val }\n        FILTER ( ?nesting != ?outerNesting)\n        FILTER EXISTS {\n      \t\t?nesting ng:in+ ?outerNesting . \n    \t}\n        FILTER ( ?prop != ng:in )\n        BIND ( ?nesting AS ?target )\n        BIND ( ?outerNesting AS ?source )\n        BIND ( ng:InheritNesting AS ?means )\n    } \n    \n    UNION\n\n    # IX    inherited, a nesting graph as subject, in any other graph\n    #       :A      :B :pH ng:IX .\n    #               :B :pK ng:IX .\n    {   \n    \tGRAPH ?extraGraph { ?nesting ?prop ?val }\n    \tFILTER NOT EXISTS { ?nesting ng:in* ?extraGraph }\n        BIND ( ?nesting AS ?target )\n        BIND ( ?extraGraph AS ?source )\n        BIND ( ng:InheritExternal AS ?means )\n    }\n\n} ORDER BY ?graph ?means ?target ?source ?prop ?val \n\n\n# graph\t    prop    val\t        target  source  means\n# :A        :pH     ng:DX       :A      :H      ng:DirectExternal\n# :A        :pK     ng:DX       :A      :K      ng:DirectExternal\n# :A        :pB     ng:DN       :A      :B      ng:DirectNesting   \n# :A        :pD     ng:DN       :A      :D      ng:DirectNesting\n# :A        :pA     ng:DS       :A      :A      ng:DirectSelf\n# :A        :pH     ng:IX       :B      :H      ng:InheritExternal\n# :A        :pK     ng:IX       :B      :K      ng:InheritExternal\n#  A        :pC     ng:IN       :B      :C      ng:InheritNesting\n# :A        :pD     ng:IS       :D      :D      ng:InheritSelf",
    "metadata": {}
  },
  {
    "kind": 1,
    "language": "markdown",
    "value": "## all graphs",
    "metadata": {}
  },
  {
    "kind": 2,
    "language": "sparql",
    "value": "# [endpoint=./feb25data.trig]\n# [use_default_graph_as_union=true]\n\nPREFIX   :   <http://rat.io/>\nPREFIX ng:   <http://rdf.ng/>\n\nSELECT DISTINCT\n    ?graph      # the graph annotated\n    ?prop       # property\n    ?val        # value\n    ?target     # the graph annotated directly\n    ?source     # the graph in which the annotation takes place\n    ?means      # the kind of access to the annotated graph\n\nWHERE {\n    \n    VALUES ?graph { :A :B :C :D :E :F :G :H :I :K :L } .\n  \n    # subquery to collect the graphs nesting ?graph\n    #       see https://stackoverflow.com/questions/5198889/\n    #   { SELECT ?graph ?nesting WHERE {\n    #       { ?graph ng:in* ?path .\n    #         ?path  ng:in+ ?nesting . } \n    #   } }\n    #   { SELECT ?nesting WHERE {\n    #         ?graph ng:in* ?path .\n    #         ?path  ng:in+ ?nesting . \n    #   } }\n    { SELECT ?nested ?nesting WHERE {\n        ?graph ng:in* ?path .\n        ?path  ng:in+ ?nesting . \n        BIND ( ?graph AS ?nested )\n    } }\n\n\n    # a graph can be annotated directly or via inheritance \n    # Direct                    directly, the graph as subject\n    #       Self        DS      in the graph itself\n    #       Nesting     DN      in a nesting graph\n    #       External    DX      in any other graph\n    # Inherit                   inherited, a nesting graph as subject\n    #       Self        IS      in the nesting graph itself\n    #       Nesting     IN      in an outer nesting graph\n    #       External    IX      in any other graph\n\n    \n    # DS    directly, the graph as subject, in the graph itself\n    #       :A      :A :pA ng:DS .\n    #       :D      :D :pD ng:IS .\n    #       :K      :K :pK ng:DS .\n    {   \n    \tGRAPH ?graph { ?graph ?prop ?val }  # no matter if graph is nested or not\n        BIND ( ?graph AS ?target )\n        BIND ( ?graph AS ?source )\n        BIND ( ng:DirectSelf AS ?means )\n    } \n  \n    UNION\n\n    # DN    directly, the graph as subject, in a nesting graph\n    #       :A      :A :pB ng:DN .\n    #               :A :pD ng:DN .\n    #       :B      :B :pC ng:IN .\n    {   \n   \t\tGRAPH ?nesting { ?graph ?prop ?val }\n        FILTER ( ?prop != ng:in )\n    \tFILTER EXISTS { ?graph ng:in+ ?nesting . }\n        BIND ( ?graph AS ?target )\n        BIND ( ?nesting AS ?source )\n        BIND ( ng:DirectNesting AS ?means )\n    } \n  \n    UNION\n\n    # DX    directly, the graph as subject, in any other graph\n    #       :A      :A :pH ng:DX .\n    #               :A :pK ng:DX .\n    #       :B      :B :pH ng:IX .\n    #               :B :pK ng:IX .\n    {   \n        GRAPH ?externalGraph { ?graph ?prop ?val . }\n        FILTER NOT EXISTS { ?graph ng:in* ?externalGraph . }\n        BIND ( ?graph AS ?target )\n        BIND ( ?externalGraph AS ?source )\n        BIND ( ng:DirectExternal AS ?means )\n    } \n\n    UNION\n    \n    # IS    inherited, a nesting graph as subject, in that graph itself\n    #       :A      :D :pD ng:IS .       \n    {   \n    \n        # { SELECT ?graph ?thisnesting WHERE {\n        #       ?graph ng:in* ?path .\n        #       ?path  ng:in+ ?thisnesting . \n        # } }\n        GRAPH ?nesting { ?nesting ?prop ?val . }\n        FILTER EXISTS { ?graph ng:in* ?nesting . }\n        BIND ( ?nested AS ?graph)\n        BIND ( ?nesting AS ?target )\n        BIND ( ?nesting AS ?source )\n        BIND ( ng:InheritSelf AS ?means )\n    } \n    \n     UNION\n     \n    # IN    inherited, a nesting graph as subject, in an outer nesting graph\n    #       :A      :B :pC ng:IN .\n    {\n    \tGRAPH ?outerNesting { ?nesting ?prop ?val }\n        FILTER EXISTS {\n      \t\t?nesting ng:in+ ?outerNesting . \n    \t}\n        FILTER ( ?nesting != ?outerNesting)\n        FILTER ( ?prop != ng:in )\n        BIND ( ?nesting AS ?target )\n        BIND ( ?outerNesting AS ?source )\n        BIND ( ng:InheritNesting AS ?means )\n    } \n  \n    UNION\n \n    # IX    inherited, a nesting graph as subject, in any other graph\n    #       :A      :B :pH ng:IX .\n    #               :B :pK ng:IX .\n    {   \n        GRAPH ?extraGraph { ?nesting ?prop ?val }\n        FILTER NOT EXISTS { ?nesting ng:in* ?extraGraph }\n        BIND ( ?nesting AS ?target )\n        BIND ( ?extraGraph AS ?source )\n        BIND ( ng:InheritExternal AS ?means )\n    }\n\n} ORDER BY ?means ?graph ?target ?source ?prop ?val \n\n# graph\t    prop    val\t        target  source  means\n# :A        :pH     ng:DX       :A      :H      ng:DirectExternal\n# :A        :pK     ng:DX       :A      :K      ng:DirectExternal\n# :B        :pH     ng:IX       :B      :H      ng:DirectExternal\n# :B        :pK     ng:IX       :B      :K      ng:DirectExternal\n\n# :A        :pB     ng:DN       :A      :B      ng:DirectNesting   \n# :A        :pD     ng:DN       :A      :D      ng:DirectNesting\n# :B        :pC     ng:IN       :B      :C      ng:DirectNesting\n\n# :A        :pA     ng:DS       :A      :A      ng:DirectSelf\n# :D        :pD     ng:IS       :D      :D      ng:DirectSelf\n# :K        :pK     ng:DS       :K      :K      ng:DirectSelf\n\n# :A        :pH     ng:IX       :B      :H      ng:InheritExternal\n# :A        :pK     ng:IX       :B      :K      ng:InheritExternal\n\n#  A        :pC     ng:IN       :B      :C      ng:InheritNesting\n\n# :A        :pD     ng:IS       :D      :D      ng:InheritSelf\n",
    "metadata": {}
  },
  {
    "kind": 1,
    "language": "markdown",
    "value": "## fragments",
    "metadata": {}
  },
  {
    "kind": 2,
    "language": "sparql",
    "value": "# the example data has been moved to a named graph\n# and the query needs to be updated accordingly\n\nPREFIX rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nPREFIX xsd:  <http://www.w3.org/2001/XMLSchema#>\nPREFIX :     <http://rat.io/>\nPREFIX ng:   <http://rdf.ng/>\n\nSELECT ?s ?pAlias ?o ?b ?c ?mm ?nn WHERE {\n\n    # search for triples\n    ?s ?p ?o\n\n    # do not show term annotations\n    # FILTER ( ?p NOT IN ( ng:onSub, ng:onPrd, ng:onObj ) )\n\n    # do follow object bnodes 2 levels deep\n    OPTIONAL {                  # only follow if object is blank\n        FILTER (isBlank(?o))    # use || or && to add patterns\n        ?o ?b ?c\n        OPTIONAL {              # add one level of indirection\n            FILTER (isBlank(?c))\n            ?c ?mm ?nn\n        }\n    }\n    \n    # don't list level-2 triples independently\n    FILTER ( !isBlank(?s) )     \n\n    # define aliases for some properties\n    BIND (  IF ( ?p=ng:onSub, \"onSubject\" ,\n            IF ( ?p=ng:onPrd, \"onPredicate\" ,\n            IF ( ?p=ng:onObj, \"onObject\" , \n            STR(?p) ) ) ) AS ?pAlias )\n}",
    "metadata": {}
  },
  {
    "kind": 1,
    "language": "markdown",
    "value": "# all together now",
    "metadata": {}
  },
  {
    "kind": 2,
    "language": "sparql",
    "value": "",
    "metadata": {}
  },
  {
    "kind": 1,
    "language": "markdown",
    "value": "# TODO\n\nunion\n    incorporate special fixes in general solution (if possible)\n    all graphs\n\nfragments\nall together now\n",
    "metadata": {}
  }
]