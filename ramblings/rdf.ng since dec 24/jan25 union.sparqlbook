[
  {
    "kind": 1,
    "language": "markdown",
    "value": "WHENEVER \n# Test [endpoint=./january25.trig]\nIS SPECIFIED THIS NOTEBOOK USES THE OXIGRAPH TRIPLE STORE\nHOWEVER, IT'S NOT POSSIBLE TO CONFIGURE THAT TRIPLE STORE AND WE CAN'T PROPERLY TEST ALL ASPECTS OF OUR APPROACH TO GRAPH INHERITANCE BECAUSE IN OXIGRAPH THE DEFAULT GRAPH IN A DATASET IS NOT CONFIGURED TO BE THE UNION OF ALL GRAPHS - AS WE WOULD NEED FOR SOME ASPECTS OF OUR APPROACH TO WORK\nTHEREFORE, SOME EXAMPLES CONCERNING NESTED GRAPHS MAY USE THE EXTERNAL AllegroGraph INSTALLATION (IN DOCKER), CONFIGURED IN THE CONNECTORS PANE ON THE LEFT\nHOWEVER, IF WE IGNORE TEH DEFAULT GRAPH - A REASONABLE ASSUMPTION TO MAKE - THEN THE ACTUAL SOURCE DOESN'T MATTER",
    "metadata": {}
  },
  {
    "kind": 1,
    "language": "markdown",
    "value": "# term annotations\n\ntodo    there must be a way to follow term annotation paths at arbitrary depth",
    "metadata": {}
  },
  {
    "kind": 2,
    "language": "sparql",
    "value": "# the example data is still in the default graph\n# it needs to be moved to a named graph\n# and the query needs to be updated accordingly\n\n# Test [endpoint=./january25.trig]\n\nPREFIX rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nPREFIX xsd:  <http://www.w3.org/2001/XMLSchema#>\nPREFIX :     <http://rat.io/>\nPREFIX ng:   <http://rdf.ng/>\n\nSELECT ?s ?pAlias ?o ?b ?c ?mm ?nn WHERE {\n\n    # search for triples\n    ?s ?p ?o\n\n    # do not show term annotations\n    # FILTER ( ?p NOT IN ( ng:onSub, ng:onPrd, ng:onObj ) )\n\n    # do follow object bnodes 2 levels deep\n    OPTIONAL {                  # only follow if object is blank\n        FILTER (isBlank(?o))    # use || or && to add patterns\n        ?o ?b ?c\n        OPTIONAL {              # add one level of indirection\n            FILTER (isBlank(?c))\n            ?c ?mm ?nn\n        }\n    }\n    \n    # don't list level-2 triples independently\n    FILTER ( !isBlank(?s) )     \n\n    # define aliases for some properties\n    BIND (  IF ( ?p=ng:onSub, \"onSubject\" ,\n            IF ( ?p=ng:onPrd, \"onPredicate\" ,\n            IF ( ?p=ng:onObj, \"onObject\" , \n            STR(?p) ) ) ) AS ?pAlias )\n}",
    "metadata": {}
  },
  {
    "kind": 1,
    "language": "markdown",
    "value": "# graph annotations\n\ntodo    1 column for all kinds of graph provenance (ng, og, ig, ag)\n        1 column to describe the kind of provenance (direct, inherited, external)",
    "metadata": {}
  },
  {
    "kind": 2,
    "language": "sparql",
    "value": "# the basic trick to construct the inheritance tree of a nested annotation\n# modeled after joshua taylor's genius answer \n# https://stackoverflow.com/questions/5198889/calculate-length-of-path-between-nodes\n\nPREFIX :     <http://rat.io/>\nPREFIX ng:   <http://rdf.ng/>\n\nselect distinct ?inner ?outer where { \n  { ?inner ng:in+ ?nesting .\n    ?nesting ng:in* ?outer . } \n}\norder by ?inner ?outer",
    "metadata": {}
  },
  {
    "kind": 2,
    "language": "sparql",
    "value": "# the basic trick to construct the inheritance tree of a nested annotation\n# modeled after joshua taylor's genius answer \n# https://stackoverflow.com/questions/5198889/calculate-length-of-path-between-nodes\n\nPREFIX :     <http://rat.io/>\nPREFIX ng:   <http://rdf.ng/>\n\n# WITHOUT GRAPH CLAUSES\n# needs default graph to be configured as union of named graphs\n# otherwise the subquery for ?nestingGraph won't work\n# AllegroGraph is by default configured this way\n# Oxigraph can be, but not from this notebook\n# Stardog can be, via 'query.all.graphs' set to TRUE\n# Dydra can be, but for unknown reasons provides incomplete results\n\n#  select distinct ?g ?nestingGraph \n#  where { \n#      ?g ng:in* ?path .\n#      ?path ng:in+ ?nestingGraph .\n#  }    \n#  order by ?g ?nestingGraph\n\n\n# WITH GRAPH CLAUSES\n\n select distinct ?g ?nestingGraph \n where { \n     graph ?gx { ?g ng:in+ ?path . } \n     graph ?gy { ?path ng:in* ?nestingGraph . } \n }    \n order by ?g ?nestingGraph",
    "metadata": {}
  },
  {
    "kind": 2,
    "language": "sparql",
    "value": "# WITHOUT GRAPH CLAUSES\n# correct results, but requiring a specific database setup:\n#   needs default graph to be configured as union of named graphs\n#   otherwise the subquery for ?nestingGraph won't work\n#   AllegroGraph is by default configured this way\n#   Oxigraph can be, but not from this notebook\n#   Stardog can be, via 'query.all.graphs' set to TRUE\n#   Dydra can be, but for unknown reasons provides incomplete results\n\nPREFIX :     <http://rat.io/>\nPREFIX ng:   <http://rdf.ng/>\n\nselect distinct \n    ?g   # the graph in question (here always :g, because of a filter below)\n    ?ng  # annotations on that graph directly in nesting graphs\n    ?og  # annotations on that graph directly in other, non-nesting graph\n    ?ig  # annotations inherited from nesting graphs in those graphs\n    ?ag  # annotations inherited from nesting graphs in other graphs\n    ?agx # those other graphs in which ag is annotated\n    ?p   # annotation property\n    ?o   # annotation value\nwhere {\n    # preliminaries: establish the graph-ness of ?g\n    graph ?g { ?x ?y ?z }   \n    # preliminaries: establish the set of graphs nesting ?g, i.e. :h, :i, :k, :l\n    #   modeled after https://stackoverflow.com/questions/5198889/\n    # WITHOUT GRAPH CLAUSES\n    #   needs default graph to be configured as union of named graphs\n    { select distinct ?g ?nestingGraph where \n        { ?g ng:in* ?path .\n          ?path ng:in+ ?nestingGraph . } order by ?g ?nestingGraph }\n    # preliminaries: don't return nesting statements\n    filter ( ?p != ng:in ) \n    # preliminaries: for the sake of the example only return results for :g\n    filter ( ?g = :g )\n\n    # G     annotations on that graph directly in the same graph\n    #       glossy  green  \n    {                         \n        graph ?g { ?g ?p ?o }\n    }\n\n    # NG    annotations on that graph directly in nesting graphs\n    #       h_gally  i_giddy  k_great\n    union {\n        graph ?nestingGraph { ?g ?p ?o . }\n        bind ( ?nestingGraph AS ?ng )\n    }\n    \n    # OG    direct annotations in other, non-nesting graphs\n    #       m_gold\n    union {\n        graph ?og { ?g ?p ?o . }\n        filter not exists { ?g ng:in* ?og }\n    }\n\n    # IG    annotations inherited from nesting graphs annotated in those same graphs\n    #       kaput\n    union {\n        graph ?nestingGraph { ?nestingGraph ?p ?o }\n        bind ( ?nestingGraph AS ?ig )\n    }\n\n    # AG    annotations inherited from nesting graphs annotated in elsewhere graphs\n    #       m_kursed\n    union {\n        graph ?agx { ?nestingGraph ?p ?o }\n        filter ( ?nestingGraph != ?agx )\n        bind ( ?nestingGraph AS ?ag )\n    }\n\n}\norder by ?g ?ng ?og ?ig ?ag ?p ?o",
    "metadata": {}
  },
  {
    "kind": 2,
    "language": "sparql",
    "value": "# WITH GRAPH CLAUSES - following j.taylor's approach on stackoverflow\n# incomplete results\n\nPREFIX :     <http://rat.io/>\nPREFIX ng:   <http://rdf.ng/>\n\nselect distinct \n    ?g   # the graph in question (here always :g, because of a filter below)\n    ?ng  # annotations on that graph directly in nesting graphs\n    ?og  # annotations on that graph directly in other, non-nesting graph\n    ?ig  # annotations inherited from nesting graphs in those graphs\n    ?ag  # annotations inherited from nesting graphs in other graphs\n    ?agx # those other graphs in which ag is annotated\n    ?p   # annotation property\n    ?o   # annotation value\nwhere {\n    # preliminaries: establish the graph-ness of ?g\n    graph ?g { ?x ?y ?z }   \n    # preliminaries: establish the set of graphs nesting ?g, i.e. :h, :i, :k, :l\n    # modeled after https://stackoverflow.com/questions/5198889/\n    { select distinct ?g ?nestingGraph where\n        {   graph ?gx { ?g ng:in+ ?path . } \n            graph ?gy { ?path ng:in* ?nestingGraph . } }\n     }\n    # preliminaries: don't return nesting statements\n    filter ( ?p != ng:in ) \n    # preliminaries: for the sake of the example only return results for :g\n    filter ( ?g = :g )\n\n    # G     annotations on that graph directly in the same graph\n    #       glossy  green  \n    {                         \n        graph ?g { ?g ?p ?o }\n    }\n\n    # NG    annotations on that graph directly in nesting graphs\n    #       h_gally  i_giddy  k_great\n    union {\n        graph ?nestingGraph { ?g ?p ?o . }\n        bind ( ?nestingGraph AS ?ng )\n    }\n    \n    # OG    direct annotations in other, non-nesting graphs\n    #       m_gold\n    union {\n        graph ?og { ?g ?p ?o . }\n        filter not exists { ?g ng:in* ?og }\n    }\n\n    # IG    annotations inherited from nesting graphs annotated in those same graphs\n    #       kaput\n    union {\n        graph ?nestingGraph { ?nestingGraph ?p ?o }\n        bind ( ?nestingGraph AS ?ig )\n    }\n\n    # AG    annotations inherited from nesting graphs annotated in elsewhere graphs\n    #       m_kursed\n    union {\n        graph ?agx { ?nestingGraph ?p ?o }\n        filter ( ?nestingGraph != ?agx )\n        bind ( ?nestingGraph AS ?ag )\n    }\n\n}\norder by ?g ?ng ?og ?ig ?ag ?p ?o",
    "metadata": {}
  },
  {
    "kind": 2,
    "language": "sparql",
    "value": "# WITH GRAPH CLAUSE - james' nesting subquery\n# strangely different results\n# and yet different and fewer results on dydra\n# TODO investigate?\n\nPREFIX :     <http://rat.io/>\nPREFIX ng:   <http://rdf.ng/>\n\nselect distinct \n    ?g   # the graph in question (here always :g, because of a filter below)\n    ?ng  # annotations on that graph directly in nesting graphs\n    ?og  # annotations on that graph directly in other, non-nesting graph\n    ?ig  # annotations inherited from nesting graphs in those graphs\n    ?ag  # annotations inherited from nesting graphs in other graphs\n    ?agx # those other graphs in which ag is annotated\n    ?p   # annotation property\n    ?o   # annotation value\nwhere {\n    # preliminaries: establish the graph-ness of ?g\n    graph ?g { ?x ?y ?z }   \n    # preliminaries: establish the set of graphs nesting ?g, i.e. :h, :i, :k, :l\n    #   # modeled after james' suggestion\n    #   # https://dydra.com/seg/nest25/@query#gdirectannotationsnonnested\n        { select distinct ?g ?nestingGraph where {\n            graph ?anyGraph { ?g ng:in* ?nestingGraph}\n        } }\n    # preliminaries: don't return nesting statements\n    filter ( ?p != ng:in ) \n    # preliminaries: for the sake of the example only return results for :g\n    filter ( ?g = :g )\n\n    # G     annotations on that graph directly in the same graph\n    #       glossy  green  \n    {                         \n        graph ?g { ?g ?p ?o }\n    }\n\n    # NG    annotations on that graph directly in nesting graphs\n    #       h_gally  i_giddy  k_great\n    union {\n        graph ?nestingGraph { ?g ?p ?o . }\n        bind ( ?nestingGraph AS ?ng )\n    }\n    \n    # OG    direct annotations in other, non-nesting graphs\n    #       m_gold\n    union {\n        graph ?og { ?g ?p ?o . }\n        filter not exists { ?g ng:in* ?og }\n    }\n\n    # IG    annotations inherited from nesting graphs annotated in those same graphs\n    #       kaput\n    union {\n        graph ?nestingGraph { ?nestingGraph ?p ?o }\n        bind ( ?nestingGraph AS ?ig )\n    }\n\n    # AG    annotations inherited from nesting graphs annotated in elsewhere graphs\n    #       m_kursed\n    union {\n        graph ?agx { ?nestingGraph ?p ?o }\n        filter ( ?nestingGraph != ?agx )\n        bind ( ?nestingGraph AS ?ag )\n    }\n\n}\norder by ?g ?ng ?og ?ig ?ag ?p ?o",
    "metadata": {}
  },
  {
    "kind": 2,
    "language": "sparql",
    "value": "# WITHOUT GRAPH CLAUSES\n# correct results, but requiring a specific database setup:\n#   needs default graph to be configured as union of named graphs\n#   otherwise the subquery for ?ng won't work\n#   AllegroGraph is by default configured this way\n#   Oxigraph can be, but not from this notebook\n#   Stardog can be, via 'query.all.graphs' set to TRUE\n#   Dydra can be, but for unknown reasons provides incomplete results\n\n# now with less columns\n\n# this gives the same results in \n#   allegrograph (here)\n#   oxigraph (run externally with default graph configured properly)\n#   stardog\n# but not in dydra\n\n# however, it is not yet correct\n# see line 58\n\nPREFIX :     <http://rat.io/>\nPREFIX ng:   <http://rdf.ng/>\n\nselect distinct \n    ?g      # the graph in question (here always :g, because of a filter below)\n    ?p      # annotation property\n    ?o      # annotation value\n    ?ngd    # graph being directly annotated\n    ?ngx    # graph containing the annotation\n    ?prv    # provenance of annotation, 5 possible values:\n            # ?g  ng:direct       in the same graph       e.g. :green, :glossy\n            # NG  ng:indirect     in a nesting graph      e.g. i_giddy\n            # OG  ng:exdirect     in a non-nesting graph  e.g. :m_gold\n            # IG  ng:inherited    on a nesting graph      e.g. :kaput\n            # AG  ng:exherited     on a nesting graph, from a non-nesting graph\n            #                                           e.g. :m_kursed\n            # yes, 'exdirect' and 'exherited' are strange and made up terms\n            #      the 'ex' stands for 'external to the nesting tree'\n#    ?ng  # annotations on that graph directly in nesting graphs            indirect\n#    ?og  # annotations on that graph directly in other, non-nesting graph  exdirect\n#    ?ig  # annotations inherited from nesting graphs in those graphs       inherited\n#    ?ag  # annotations inherited from nesting graphs in other graphs       exherited\n#    ?agx # those other graphs in which ag is annotated\nwhere {\n    # preliminaries: establish the graph-ness of ?g\n    graph ?g { ?x ?y ?z }   \n    # preliminaries: establish the set of graphs nesting ?g, i.e. :h, :i, :k, :l\n    #   modeled after https://stackoverflow.com/questions/5198889/\n    # WITHOUT GRAPH CLAUSES\n    #   needs default graph to be configured as union of named graphs\n    { select distinct ?g ?ng where \n        { ?g ng:in* ?path .\n          ?path ng:in+ ?ng . } order by ?g ?ng }\n    # preliminaries: don't return nesting statements\n    filter ( ?p != ng:in ) \n    # preliminaries: for the sake of the example only return results for :g\n    filter ( ?g = :g )\n    # TODO missing graphs :l and :v if this filter is deactivated\n\n    # G     annotations on that graph directly in the same graph\n    #       glossy  green  \n    {                         \n        graph ?g { ?g ?p ?o }\n        bind ( ?g AS ?ngd )\n        bind ( ?g AS ?ngx )\n        bind ( ng:direct AS ?prv)\n    }\n\n    # NG    annotations on that graph directly in nesting graphs\n    #       h_gally  i_giddy  k_great\n    union {\n        graph ?ng { ?g ?p ?o . }\n        bind ( ?g AS ?ngd )\n        bind ( ?ng AS ?ngx )\n        bind ( ng:indirect AS ?prv )\n    }\n    \n    # OG    direct annotations in other, non-nesting graphs\n    #       m_gold\n    union {\n        graph ?og { ?g ?p ?o . }\n        filter not exists { ?g ng:in* ?og }\n        bind ( ?g AS ?ngd )\n        bind ( ?og AS ?ngx )\n        bind ( ng:exdirect AS ?prv )\n    }\n\n    # IG    annotations inherited from nesting graphs annotated in those same graphs\n    #       kaput\n    union {\n        graph ?ng { ?ng ?p ?o }\n        bind ( ?ng AS ?ngd )\n        bind ( ?ng AS ?ngx )\n        bind ( ng:inherited AS ?prv )\n    }\n\n    # AG    annotations inherited from nesting graphs annotated in elsewhere graphs\n    #       m_kursed\n    union {\n        graph ?ngx { ?ng ?p ?o }\n        filter ( ?ng != ?ngx )\n        bind ( ?ng AS ?ngd )\n        # bind ( ?ngx AS ?ngx )\n        bind ( ng:xherited AS ?prv )\n    }\n\n}\norder by ?g ?prv ?ng ?ngx ?p ?o",
    "metadata": {}
  },
  {
    "kind": 2,
    "language": "sparql",
    "value": "# and now with OPTIONAL instead of union\n# \n#       NOT YET WORKING\n# \n# WITHOUT GRAPH CLAUSES\n# correct results, but requiring a specific database setup:\n#   needs default graph to be configured as union of named graphs\n#   otherwise the subquery for ?ng won't work\n#   AllegroGraph is by default configured this way\n#   Oxigraph can be, but not from this notebook\n#   Stardog can be, via 'query.all.graphs' set to TRUE\n#   Dydra can be, but for unknown reasons provides incomplete results\n\n# now with less columns\n\nPREFIX :     <http://rat.io/>\nPREFIX ng:   <http://rdf.ng/>\n\nselect distinct \n    ?g      # the graph in question \n#   ?ng     # as returned from the sub select\n            #   for testing only \n    ?p      # annotation property\n    ?o      # annotation value\n    ?ngd    # graph being directly annotated\n    ?ngx    # graph containing the annotation\n#   ?gn\n#   ?ngn\n#   ?go \n#   ?ngo\n    ?prv    # provenance of annotation, 5 possible values:\n            # ?g  ng:direct       in the same graph       e.g. :green, :glossy\n            # NG  ng:indirect     in a nesting graph      e.g. i_giddy\n            # OG  ng:exdirect     in a non-nesting graph  e.g. :m_gold\n            # IG  ng:inherited    on a nesting graph      e.g. :kaput\n            # AG  ng:exherited     on a nesting graph, from a non-nesting graph\n            #                                           e.g. :m_kursed\n            # yes, 'exdirect' and 'exherited' are strange and made up terms\n            #      the 'ex' stands for 'external to the nesting tree'\nwhere {\n    # for the sake of the example only return results for :g\n    filter ( ?ngd = :g )\n\n    # establish the graph-ness of ?g\n    # here  :g  :h  :i  :k  :l  :m  :o  :v\n    # but for now ignore the statements it contains\n    graph ?g { ?x ?y ?z }   \n\n    # establish the set of graphs nesting ?g, if any\n    # here for :g    :h  :i  :k  :l\n    #   modeled after https://stackoverflow.com/questions/5198889/\n    #   default graph configured as union of named graphs\n    { select distinct ?ng ?gn ?ngn ?go ?ngo where {\n        optional {\n            { ?g ng:in* ?path .\n              ?path ng:in+ ?ng . } \n            bind ( ?g AS ?gn )\n            bind ( ?ng AS ?ngn )\n            bind ( ?g AS ?go )\n            bind ( ?ng AS ?ngo )\n        }\n    } }\n\n    # G     annotations on that graph directly in the same graph\n    #       for :g  g:glossy  g:green  \n    #       non-:g  k:kaput  m:morbid  o:oblique\n    optional {                         \n        graph ?g { ?g ?p ?o }\n        bind ( ?g AS ?ngd )\n        bind ( ?g AS ?ngx )\n        bind ( ng:direct AS ?prv)\n    }\n \n    # NG    annotations on that graph directly in nesting graphs\n    #       for :g  h_gally  i_giddy  k_great\n    #       non-:g  o_verbose\n    #               which interestingly enough is an annotation \n    #               on a NESTING graph, i.e. upwards, not downwards\n    #               TODO  results from :ng being a set, not an ordered list\n    optional {\n        graph ?ngn { ?gn ?p ?o . }\n        bind ( ?gn AS ?ngd )\n        bind ( ?ngn AS ?ngx )\n        bind ( ng:indirect AS ?prv )\n        filter ( ?p != ng:in )\n    }\n    \n    # OG    direct annotations in other, non-nesting graphs\n    #       for :g  m_gold\n    #       non-:g  m_kursed  o_verbose\n#    optional {\n#        graph ?og { ?g ?p ?o . }\n#        filter not exists { ?g ng:in* ?og }\n#        bind ( ?g AS ?ngd )\n#        bind ( ?og AS ?ngx )\n#        bind ( ng:exdirect AS ?prv )\n#    }\n\n     # IG    annotations inherited from nesting graphs annotated in those same graphs\n     #       here: kaput\n#    optional {\n#        graph ?ng { ?ng ?p ?o }\n#        filter ( ?p != ng:in )\n#        bind ( ?ng AS ?ngd )\n#        bind ( ?ng AS ?ngx )\n#        bind ( ng:inherited AS ?prv )\n#    }\n\n     # AG    annotations inherited from nesting graphs annotated in elsewhere graphs\n     #       here: m_kursed\n#    optional {\n#        graph ?ngx { ?ng ?p ?o }\n#        filter ( ?ng != ?ngx )\n#        bind ( ?ng AS ?ngd )\n#        # bind ( ?ngx AS ?ngx )\n#        bind ( ng:exherited AS ?prv )\n#    }\n\n}\norder by ?g ?ng ?ngd ?ngx ?prv ?p ?o",
    "metadata": {}
  },
  {
    "kind": 1,
    "language": "markdown",
    "value": "re-binding variables is possible",
    "metadata": {}
  },
  {
    "kind": 2,
    "language": "sparql",
    "value": "PREFIX :     <http://rat.io/>\nPREFIX ng:   <http://rdf.ng/>\n\nselect ?g ?bg ?bbg where {\n    graph ?bg { ?u ?v :ko }\n    bind ( ?bg as ?bbg )\n    { select ?g ?bg where {\n        graph ?g { ?s ?p :kaput }\n        bind ( ?g as ?bg )\n    } }\n}",
    "metadata": {}
  },
  {
    "kind": 1,
    "language": "markdown",
    "value": "variables from sub-queries **are** available in optional clauses",
    "metadata": {}
  },
  {
    "kind": 2,
    "language": "sparql",
    "value": "PREFIX   :   <http://rat.io/>\nPREFIX ng:   <http://rdf.ng/>\n\nselect distinct ?inner ?outer ?extra where {\n    # insert into 'values' the graphs(s) to query for\n    values ?inner { :g }\n    \n    # construct the list of nesting graphs\n    { select ?inner ?outer where {\n        # replace by proper nesting query \n        ?inner ng:in ?outer .\n    } }\n\n    # find more\n    optional {\n        ?outer ?p ?extra .\n    }\n} order by ?inner ?outer ?extra\n",
    "metadata": {}
  }
]